<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sticker Pack Game</title>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <style>
    * {
      box-sizing: border-box;
    }

    body {
      font-family: Arial, sans-serif;
      background: #f5f5f5;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      touch-action: pan-y;
      overflow-y: auto;
      min-height: 100vh;
    }

    /* Auth styles */
    #auth-box {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.98);
      z-index: 1000;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }

    #auth-box h2 {
      margin-bottom: 20px;
      color: #333;
    }

    #auth-box input {
      width: 100%;
      max-width: 300px;
      padding: 12px;
      margin: 8px 0;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 16px;
    }

    #auth-box button {
      width: 100%;
      max-width: 300px;
      padding: 12px;
      margin: 8px 0;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 16px;
      cursor: pointer;
    }

    #auth-box button:active {
      background: #45a049;
    }

    #auth-box button.secondary {
      background: #2196F3;
    }

    #auth-box button.secondary:active {
      background: #1976D2;
    }

    #auth-status {
      margin-top: 10px;
      color: #666;
      font-size: 14px;
      text-align: center;
      min-height: 20px;
    }

    body.locked {
      overflow: hidden;
    }

    body.locked #sticker-area,
    body.locked #open-pack,
    body.locked header button:not(#logout-btn) {
      opacity: 0.3;
      pointer-events: none;
    }

    #logout-btn {
      background: #ff6b6b;
      color: white;
    }

    #logout-btn:active {
      background: #ff4757;
    }

    #welcome-message {
      font-weight: bold;
      padding: 8px 12px;
      background: white;
      border-radius: 4px;
      border: 1px solid #999;
      min-width: 120px;
      text-align: center;
    }

    /* Main game styles */
    header {
      width: 100%;
      background: #eee;
      padding: 10px;
      display: flex;
      justify-content: center;
      gap: 10px;
      align-items: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      flex-wrap: wrap;
      position: relative;
      z-index: 100;
    }

    header button {
      font-size: 14px;
      padding: 12px 16px;
      cursor: pointer;
      min-height: 44px;
      min-width: 44px;
      border: 1px solid #999;
      background: #fff;
      border-radius: 4px;
      font-weight: 500;
    }

    header button:active {
      background: #ddd;
    }

    #coins, #packs {
      font-weight: bold;
      font-size: 14px;
      padding: 8px 12px;
      background: #fff;
      border-radius: 4px;
      border: 1px solid #999;
      min-width: 120px;
      text-align: center;
    }

    #sticker-area {
      margin-top: 20px;
      width: 95%;
      max-width: 800px;
      height: 60vh;
      min-height: 300px;
      background: #fff;
      border: 1px solid #ccc;
      position: relative;
      overflow: hidden;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .sticker-card {
      width: 160px;
      height: 240px;
      border: 2px solid #333;
      background: #ddd;
      position: absolute;
      transform-style: preserve-3d;
      transition: transform 0.5s, left 0.8s ease-out, top 0.8s ease-out;
      user-select: none;
      touch-action: none;
      cursor: pointer;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
      border-radius: 8px;
    }

    .sticker-card:active {
      transform: scale(0.95);
    }

    .sticker-card.flipped {
      transform: rotateY(180deg) !important;
    }

    .sticker-card.flipped:active {
      transform: rotateY(180deg) scale(0.95) !important;
    }

    .sticker-card.stacked {
      z-index: 10;
    }

    .sticker-card.spread {
      z-index: 1;
    }

    .sticker-front, .sticker-back {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 48px;
      font-weight: bold;
      border-radius: 6px;
    }

    .sticker-front {
      background: linear-gradient(45deg, #ff6b6b, #ffa500);
      color: white;
    }

    .sticker-back {
      transform: rotateY(180deg);
      flex-direction: column;
      background: white;
      overflow: hidden;
      padding: 10px;
    }

    .sticker-back img {
      max-width: 140px;
      max-height: 190px;
      object-fit: contain;
      margin-bottom: 5px;
      transition: transform 0.3s;
    }

    .sticker-back img.landscape {
      transform: rotate(90deg);
      max-width: 190px;
      max-height: 140px;
    }

    .sticker-back .card-number {
      font-size: 18px;
      font-weight: bold;
      margin-top: 5px;
    }

    .sticker-back.has-landscape .card-number {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
    }

    #open-pack {
      margin: 20px 0;
      padding: 16px 32px;
      font-size: 18px;
      background: #32cd32;
      color: #fff;
      border: none;
      cursor: pointer;
      border-radius: 8px;
      font-weight: bold;
      min-height: 56px;
      min-width: 250px;
      box-shadow: 0 4px 12px rgba(50, 205, 50, 0.3);
      transition: all 0.2s;
    }

    #open-pack:active {
      transform: scale(0.95);
      box-shadow: 0 2px 8px rgba(50, 205, 50, 0.3);
    }

    #open-pack.disabled {
      background: #999;
      cursor: not-allowed;
      box-shadow: none;
    }

    #album, #duplicates {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #fff;
      overflow: auto;
      padding: 60px 20px 20px 20px;
      z-index: 100;
    }

    .album-grid, .duplicates-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 10px;
      margin-top: 20px;
      padding-bottom: 20px;
    }

    @media (min-width: 600px) {
      .album-grid, .duplicates-grid {
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      }

      header button {
        font-size: 16px;
      }

      #coins, #packs {
        font-size: 16px;
      }

      #open-pack {
        font-size: 20px;
      }
    }

    .album-slot, .duplicate-slot {
      width: 100%;
      height: 160px;
      border: 1px solid #888;
      background: #eee;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      font-size: 36px;
      color: #aaa;
      overflow: hidden;
      border-radius: 4px;
    }

    @media (min-width: 600px) {
      .album-slot, .duplicate-slot {
        height: 200px;
        font-size: 48px;
      }
    }

    .album-slot img, .duplicate-slot img {
      max-width: 100%;
      max-height: 120px;
      object-fit: contain;
      margin-bottom: 5px;
    }

    @media (min-width: 600px) {
      .album-slot img, .duplicate-slot img {
        max-height: 160px;
      }
    }

    .album-slot img.landscape, .duplicate-slot img.landscape {
      transform: rotate(90deg);
      max-width: 120px;
      max-height: 100px;
    }

    @media (min-width: 600px) {
      .album-slot img.landscape, .duplicate-slot img.landscape {
        max-width: 160px;
        max-height: 100px;
      }
    }

    .album-slot .slot-number, .duplicate-slot .slot-number {
      font-size: 12px;
      font-weight: bold;
    }

    .album-slot.has-landscape .slot-number,
    .duplicate-slot.has-landscape .slot-number {
      position: absolute;
      bottom: 5px;
      left: 50%;
      transform: translateX(-50%);
    }

    .close-btn {
      position: fixed;
      top: 10px;
      right: 10px;
      cursor: pointer;
      font-size: 24px;
      font-weight: bold;
      padding: 8px 16px;
      border: 1px solid #333;
      background: #ddd;
      border-radius: 4px;
      min-height: 44px;
      min-width: 44px;
      z-index: 101;
    }

    .close-btn:active {
      background: #ccc;
    }

    #sell-duplicates {
      position: sticky;
      bottom: 0;
      left: 0;
      right: 0;
      width: 100%;
      padding: 16px;
      font-size: 18px;
      background: #32cd32;
      color: white;
      border: none;
      cursor: pointer;
      font-weight: bold;
      margin-top: 20px;
      border-radius: 8px;
      min-height: 56px;
    }

    #sell-duplicates:active {
      background: #28a428;
    }

    h2 {
      margin: 0 0 10px 0;
      text-align: center;
    }

    /* Simple Trading Styles */
    #simple-trading {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #fff;
      overflow: auto;
      padding: 60px 20px 20px 20px;
      z-index: 100;
    }

    .trading-code-input {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      margin: 30px 0;
    }

    .trading-code-input input {
      width: 200px;
      padding: 15px;
      font-size: 24px;
      text-align: center;
      border: 3px solid #4CAF50;
      border-radius: 10px;
      letter-spacing: 10px;
      font-weight: bold;
    }

    .trading-code-input button {
      padding: 15px 30px;
      font-size: 18px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
    }

    .trading-code-input button:active {
      background: #45a049;
    }

    #trade-status {
      margin-top: 20px;
      text-align: center;
      font-size: 16px;
      color: #666;
      min-height: 40px;
    }

    .trading-match-found {
      background: #e8f5e8;
      padding: 15px;
      border-radius: 10px;
      border: 2px solid #4CAF50;
      margin: 20px 0;
    }

    .trade-stickers-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 15px;
      margin: 20px 0;
      max-height: 400px;
      overflow-y: auto;
      padding: 10px;
      background: #f5f5f5;
      border-radius: 10px;
    }

    .trade-sticker-item {
      border: 2px solid #ddd;
      border-radius: 8px;
      padding: 10px;
      background: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      cursor: pointer;
      transition: all 0.2s;
    }

    .trade-sticker-item:hover {
      border-color: #4CAF50;
      transform: scale(1.05);
    }

    .trade-sticker-item.selected {
      border-color: #4CAF50;
      background: #e8f5e8;
    }

    .trade-sticker-item img {
      max-width: 80px;
      max-height: 80px;
      object-fit: contain;
    }

    .trade-sticker-item .sticker-number {
      font-size: 12px;
      margin-top: 5px;
      font-weight: bold;
      color: #333;
    }

    .trade-actions {
      display: flex;
      gap: 15px;
      justify-content: center;
      margin-top: 30px;
    }

    .trade-actions button {
      padding: 15px 30px;
      font-size: 18px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
    }

    #confirm-trade-btn {
      background: #4CAF50;
      color: white;
    }

    #cancel-trade-btn {
      background: #ff6b6b;
      color: white;
    }

    #trading-btn {
      background: #9C27B0;
      color: white;
    }

    #trading-btn:active {
      background: #7B1FA2;
    }
  </style>
</head>

<body class="locked">

<div id="auth-box">
  <h2>Sticker Pack Game</h2>
  <p style="color: #666; text-align: center; margin-bottom: 20px; max-width: 300px;">
    Create an account or login to start collecting stickers!
  </p>
  <input type="text" id="username" placeholder="Username" required minlength="3" maxlength="20">
  <input type="password" id="password" placeholder="Password" required minlength="6">
  <button id="signup-btn" class="secondary">Sign Up</button>
  <button id="login-btn">Login</button>
  <div id="auth-status"></div>
</div>

<header>
  <button id="album-btn">üìñ ALBUM</button>
  <button id="duplicates-btn">üìÇ DUPES</button>
  <button id="save-btn">üíæ SAVE</button>
  <button id="reset-btn">üîÑ RESET</button>
  <div id="coins">üí∞ Coins: 100</div>
  <div id="packs">üì¶ Packs: 0</div>
  <button id="coin-flip">ü™ô Coin Flip</button>
  <button id="trading-btn">ü§ù TRADE</button>
  <button id="logout-btn" style="display: none;">üö™ Logout</button>
</header>

<div id="sticker-area"></div>

<button id="open-pack">üéÅ OPEN PACK (5 Coins)</button>

<div id="album">
  <div class="close-btn" onclick="document.getElementById('album').style.display='none'">‚úñ</div>
  <h2>Sticker Album</h2>
  <div class="album-grid" id="album-grid"></div>
</div>

<div id="duplicates">
  <div class="close-btn" onclick="document.getElementById('duplicates').style.display='none'">‚úñ</div>
  <h2>Duplicates</h2>
  <div class="duplicates-grid" id="duplicates-grid"></div>
  <button id="sell-duplicates">üí∞ Sell All Duplicates</button>
</div>

<!-- Simple Trading UI -->
<div id="simple-trading">
  <div class="close-btn" onclick="closeTrading()">‚úñ</div>
  <h2>Sticker Trading</h2>

  <div style="text-align: center; max-width: 600px; margin: 0 auto;">
    <p style="color: #666; margin-bottom: 30px;">
      Enter a 4-digit code to find another player for trading.
      Both players must enter the same code at the same time.
    </p>

    <div class="trading-code-input">
      <input type="text" id="trade-code" placeholder="1234" maxlength="4" pattern="\d{4}">
      <button id="enter-trade-code">Enter Trade Code</button>
    </div>

    <div id="trade-status">Waiting for code...</div>

    <div id="trade-match-section" style="display: none;">
      <div class="trading-match-found">
        <h3>üéâ Trade Match Found!</h3>
        <p>You're now connected with another player.</p>
        <p><strong>Select your duplicate stickers to trade:</strong></p>
      </div>

      <div class="trade-stickers-grid" id="my-trade-duplicates"></div>

      <div id="selected-trade-stickers" style="margin: 20px 0; padding: 15px; background: #f0f0f0; border-radius: 8px; min-height: 60px;">
        <p style="margin: 0; color: #999;">Your selected stickers will appear here...</p>
      </div>

      <div class="trade-actions">
        <button id="confirm-trade-btn">‚úÖ Confirm Trade</button>
        <button id="cancel-trade-btn">‚ùå Cancel</button>
      </div>
    </div>
  </div>
</div>

<script>
  const supabaseUrl = "https://djpxosljltycswayletr.supabase.co";
  const supabaseKey = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRqcHhvc2xqbHR5Y3N3YXlsZXRyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njg5MTU5MjMsImV4cCI6MjA4NDQ5MTkyM30.bPesylaMS5wJSmHl3mIr2Ql3gAI5snULpBnBVdJYP2w";
  const supabaseClient = window.supabase.createClient(supabaseUrl, supabaseKey);

  const STICKERS_TOTAL = 700;
  let coins = 100;
  let packsOpened = 0;
  const userCollection = [];
  const duplicates = {};

  const stickerArea = document.getElementById('sticker-area');
  const coinsLabel = document.getElementById('coins');
  const packsLabel = document.getElementById('packs');
  const openPackBtn = document.getElementById('open-pack');
  const authBox = document.getElementById("auth-box");
  const statusText = document.getElementById("auth-status");

  // Haptic feedback
  function vibrate(duration = 10) {
    if ('vibrate' in navigator) {
      navigator.vibrate(duration);
    }
  }

  // Setup image rotation
  function setupImageRotation(img, stickerNum, cardBack) {
    img.onload = function() {
      if (this.naturalWidth > this.naturalHeight) {
        this.classList.add('landscape');
        if (cardBack) {
          cardBack.classList.add('has-landscape');
        }
      }
    };
    img.onerror = function() {
      const parent = this.parentElement;
      parent.innerHTML = `<div style='font-size:60px;color:#333'>#${stickerNum}</div>`;
    };
  }

  // Helper function to generate unique email from username
  function generateEmailFromUsername(username) {
    return `${username.toLowerCase().replace(/[^a-z0-9]/g, '')}@sticker.game`;
  }

  // Sign up with username
  async function signUpWithUsername() {
    const username = document.getElementById("username").value.trim();
    const password = document.getElementById("password").value;

    if (!username || !password) {
      statusText.textContent = "Please enter username and password";
      statusText.style.color = "#ff6b6b";
      return;
    }

    if (username.length < 3) {
      statusText.textContent = "Username must be at least 3 characters";
      statusText.style.color = "#ff6b6b";
      return;
    }

    if (password.length < 6) {
      statusText.textContent = "Password must be at least 6 characters";
      statusText.style.color = "#ff6b6b";
      return;
    }

    const usernameRegex = /^[a-zA-Z0-9_]{3,20}$/;
    if (!usernameRegex.test(username)) {
      statusText.textContent = "Username can only contain letters, numbers, and underscores";
      statusText.style.color = "#ff6b6b";
      return;
    }

    statusText.textContent = "Creating account...";
    statusText.style.color = "#666";

    try {
      const email = generateEmailFromUsername(username);

      // Check if username already exists
      const { data: existingUser } = await supabaseClient
              .from('profiles')
              .select('username')
              .eq('username', username)
              .single();

      if (existingUser) {
        statusText.textContent = "Username already taken!";
        statusText.style.color = "#ff6b6b";
        return;
      }

      // Sign up with Supabase
      const { data, error } = await supabaseClient.auth.signUp({
        email,
        password,
        options: {
          data: {
            username: username,
            display_name: username
          }
        }
      });

      if (error) {
        if (error.message.includes("already registered")) {
          statusText.textContent = "Account already exists! Please login instead.";
        } else {
          statusText.textContent = error.message;
        }
        statusText.style.color = "#ff6b6b";
        return;
      }

      // Create profile entry
      if (data.user) {
        const { error: profileError } = await supabaseClient
                .from('profiles')
                .upsert({
                  id: data.user.id,
                  username: username,
                  created_at: new Date().toISOString()
                });

        if (profileError) {
          statusText.textContent = "Error creating profile: " + profileError.message;
          statusText.style.color = "#ff6b6b";
          await supabaseClient.auth.signOut();
          return;
        }

        // Create initial save data
        await createInitialSave(data.user.id);

        statusText.textContent = `Welcome ${username}! Account created successfully!`;
        statusText.style.color = "#32cd32";

        setTimeout(() => {
          hideAuthBox();
          loadGame();
        }, 1500);
      }
    } catch (err) {
      statusText.textContent = "Error: " + err.message;
      statusText.style.color = "#ff6b6b";
    }
  }

  // Create initial save data
  async function createInitialSave(userId) {
    const initialData = {
      id: userId,
      coins: 100,
      packs_opened: 0,
      collection: [],
      duplicates: {}
    };

    const { error } = await supabaseClient
            .from("saves")
            .upsert(initialData, { onConflict: 'id' });

    if (error) {
      console.error("Error creating initial save:", error);
    }
  }

  // Login with username
  async function loginWithUsername() {
    const username = document.getElementById("username").value.trim();
    const password = document.getElementById("password").value;

    if (!username || !password) {
      statusText.textContent = "Please enter username and password";
      statusText.style.color = "#ff6b6b";
      return;
    }

    statusText.textContent = "Logging in...";
    statusText.style.color = "#666";

    try {
      const { data: profileData, error: profileError } = await supabaseClient
              .from('profiles')
              .select('username')
              .eq('username', username)
              .single();

      if (profileError || !profileData) {
        statusText.textContent = "Username not found!";
        statusText.style.color = "#ff6b6b";
        return;
      }

      const email = generateEmailFromUsername(username);

      const { error } = await supabaseClient.auth.signInWithPassword({
        email,
        password
      });

      if (error) {
        if (error.message.includes("Invalid login credentials")) {
          statusText.textContent = "Incorrect password!";
        } else {
          statusText.textContent = error.message;
        }
        statusText.style.color = "#ff6b6b";
      } else {
        statusText.textContent = `Welcome back ${username}!`;
        statusText.style.color = "#32cd32";

        setTimeout(() => {
          hideAuthBox();
          loadGame();
        }, 1000);
      }
    } catch (err) {
      statusText.textContent = "Error: " + err.message;
      statusText.style.color = "#ff6b6b";
    }
  }

  async function logout() {
    await supabaseClient.auth.signOut();
    location.reload();
  }

  function hideAuthBox() {
    authBox.style.display = "none";
    document.body.classList.remove("locked");
  }

  // Get current user's username
  async function getCurrentUsername() {
    const { data: { user } } = await supabaseClient.auth.getUser();
    if (!user) return null;

    const { data } = await supabaseClient
            .from('profiles')
            .select('username')
            .eq('id', user.id)
            .single();

    return data?.username || user.email?.split('@')[0] || 'User';
  }

  // Update header to show username
  async function updateUserDisplay() {
    const username = await getCurrentUsername();
    if (username) {
      let welcomeElement = document.getElementById('welcome-message');

      if (!welcomeElement) {
        welcomeElement = document.createElement('div');
        welcomeElement.id = 'welcome-message';
        welcomeElement.style.cssText = `
        font-weight: bold;
        padding: 8px 12px;
        background: white;
        border-radius: 4px;
        border: 1px solid #999;
        min-width: 120px;
        text-align: center;
      `;

        const packsDiv = document.getElementById('packs');
        if (packsDiv) {
          packsDiv.parentNode.insertBefore(welcomeElement, packsDiv.nextSibling);
        }
      }

      welcomeElement.textContent = `üëã ${username}`;
    }
  }

  // Save game function
  async function saveGame() {
    const { data: { user } } = await supabaseClient.auth.getUser();

    if (!user) {
      console.error("Cannot save: No user logged in");
      return false;
    }

    const data = {
      id: user.id,
      coins: coins,
      packs_opened: packsOpened,
      collection: userCollection,
      duplicates: duplicates,
      updated_at: new Date().toISOString()
    };

    const { error } = await supabaseClient
            .from("saves")
            .upsert(data, { onConflict: 'id' });

    if (error) {
      console.error("Save failed:", error);
      //("Failed to save game: " + error.message);
      return false;
    } else {
      console.log("Game saved to cloud successfully");
      return true;
    }
  }

  // Load game from Supabase
  async function loadGame() {
    const { data: { user } } = await supabaseClient.auth.getUser();

    if (!user) {
      authBox.style.display = "flex";
      document.body.classList.add("locked");
      return;
    }

    // Show logout button
    document.getElementById("logout-btn").style.display = "inline-block";

    // Load from Supabase
    const { data, error } = await supabaseClient
            .from("saves")
            .select("*")
            .eq("id", user.id)
            .single();

    if (error) {
      console.error("Load error:", error);

      // If no save exists, create one
      if (error.code === 'PGRST116') {
        console.log("No save found, creating initial save...");
        await createInitialSave(user.id);
      }
    } else if (data) {
      // Load game data
      coins = data.coins ?? 100;
      packsOpened = data.packs_opened ?? 0;

      // Clear and reload collections
      userCollection.length = 0;
      if (data.collection && Array.isArray(data.collection)) {
        userCollection.push(...data.collection);
      }

      // Clear and reload duplicates
      for (let key in duplicates) delete duplicates[key];
      if (data.duplicates && typeof data.duplicates === 'object') {
        Object.assign(duplicates, data.duplicates);
      }
    }

    // Update user display and labels
    await updateUserDisplay();
    updateLabels();
  }

  // Coin flip game
  async function coinFlipGame() {
    const { data: { user } } = await supabaseClient.auth.getUser();
    if (!user) {
      //("Please login first!");
      return;
    }

    if (coins < 10) {
      //("Not enough coins! Need 10 coins to play.");
      return;
    }

    coins -= 10;
    const win = Math.random() < 0.75;

    if (win) {
      coins += 25;
      //("You won 25 coins! üéâ");
    } else {
      //("You lost 10 coins üò≠");
    }

    updateLabels();
    await saveGame();
  }

  // Reset game
  async function resetGame() {
    if (!confirm("Are you sure you want to reset your account? You'll lose all progress!")) {
      return;
    }

    coins = 100;
    packsOpened = 0;
    userCollection.length = 0;

    for (let key in duplicates) {
      delete duplicates[key];
    }

    updateLabels();
    stickerArea.innerHTML = '';

    const saved = await saveGame();
    if (saved) {
      vibrate(30);
      //("Game reset successfully!");
    } else {
      //("Failed to reset game!");
    }
  }

  // Update UI labels
  function updateLabels() {
    coinsLabel.textContent = `üí∞ Coins: ${coins}`;
    packsLabel.textContent = `üì¶ Packs: ${packsOpened}`;
    openPackBtn.classList.toggle('disabled', coins < 5);
  }

  // Get random stickers
  function getRandomStickers(count) {
    const nums = Array.from({length: STICKERS_TOTAL}, (_, i) => i + 1);
    nums.sort(() => Math.random() - 0.5);
    return nums.slice(0, count);
  }

  // Open pack function
  async function openPack() {
    const { data: { user } } = await supabaseClient.auth.getUser();
    if (!user) {
      //("Please login first!");
      return;
    }

    if (coins < 5) {
      //("Not enough coins!");
      return;
    }

    coins -= 5;
    packsOpened++;
    updateLabels();
    vibrate(50);

    stickerArea.innerHTML = '';
    const stickers = getRandomStickers(5);

    const centerX = stickerArea.offsetWidth / 2 - 80;
    const centerY = stickerArea.offsetHeight / 2 - 120;

    stickers.forEach((num, i) => {
      const card = document.createElement('div');
      card.className = 'sticker-card stacked';
      card.dataset.number = num;

      card.style.left = `${centerX + i * 2}px`;
      card.style.top = `${centerY + i * 2}px`;

      const img = document.createElement('img');
      img.src = `images/${num}.png`;
      img.alt = `Sticker #${num}`;

      card.innerHTML = `
      <div class="sticker-front">?</div>
      <div class="sticker-back">
        <div id="img-container-${num}"></div>
        <div class="card-number">#${num}</div>
      </div>
    `;

      const cardBack = card.querySelector('.sticker-back');
      setupImageRotation(img, num, cardBack);

      const imgContainer = card.querySelector(`#img-container-${num}`);
      imgContainer.appendChild(img);

      card.addEventListener('click', function flipCard() {
        if (!card.classList.contains('flipped')) {
          card.classList.add('flipped');
          vibrate(15);
        }
      });

      stickerArea.appendChild(card);

      // Add to collection or duplicates
      if (userCollection.includes(num)) {
        duplicates[num] = (duplicates[num] || 0) + 1;
      } else {
        userCollection.push(num);
      }
    });

    // Animate cards spreading
    setTimeout(() => {
      const cards = document.querySelectorAll('.sticker-card');
      const areaWidth = stickerArea.offsetWidth;
      const areaHeight = stickerArea.offsetHeight;

      const isMobile = areaWidth < 600;
      const cardsPerRow = isMobile ? Math.min(3, cards.length) : 5;

      cards.forEach((card, i) => {
        card.classList.remove('stacked');
        card.classList.add('spread');

        const row = Math.floor(i / cardsPerRow);
        const col = i % cardsPerRow;

        const cardWidth = 160;
        const cardHeight = 240;
        const spacing = isMobile ? 10 : 20;

        const totalWidth = cardsPerRow * cardWidth + (cardsPerRow - 1) * spacing;
        const startX = (areaWidth - totalWidth) / 2;
        const startY = (areaHeight - cardHeight) / 2 - row * (cardHeight / 2);

        const finalX = startX + col * (cardWidth + spacing);
        const finalY = Math.max(10, startY + row * (cardHeight + spacing));

        card.style.left = `${finalX}px`;
        card.style.top = `${finalY}px`;
      });
    }, 300);

    // Save after opening pack
    await saveGame();
  }

  // Album functions
  function refreshAlbum() {
    const grid = document.getElementById('album-grid');
    grid.innerHTML = '';
    for (let i = 1; i <= STICKERS_TOTAL; i++) {
      const slot = document.createElement('div');
      slot.className = 'album-slot';

      if (userCollection.includes(i)) {
        const img = document.createElement('img');
        img.src = `images/${i}.png`;
        img.alt = `Sticker #${i}`;

        img.onload = function() {
          if (this.naturalWidth > this.naturalHeight) {
            this.classList.add('landscape');
            slot.classList.add('has-landscape');
          }
        };
        img.onerror = function() {
          const parent = this.parentElement;
          parent.innerHTML = `<div style='font-size:24px;color:#333'>#${i}</div>`;
        };

        slot.innerHTML = `<div class="slot-number">#${i}</div>`;
        slot.insertBefore(img, slot.firstChild);
      } else {
        slot.innerHTML = '?';
      }

      grid.appendChild(slot);
    }
  }

  // Duplicates functions
  function refreshDuplicates() {
    const grid = document.getElementById('duplicates-grid');
    grid.innerHTML = '';

    const duplicateKeys = Object.keys(duplicates);

    if (duplicateKeys.length === 0) {
      grid.innerHTML = '<p style="grid-column: 1/-1; text-align: center; color: #999; padding: 40px;">No duplicates yet!</p>';
      return;
    }

    duplicateKeys.forEach(key => {
      const i = parseInt(key);
      const count = duplicates[key];

      const slot = document.createElement('div');
      slot.className = 'duplicate-slot';
      slot.style.position = 'relative';

      const img = document.createElement('img');
      img.src = `images/${i}.png`;
      img.alt = `Sticker #${i}`;

      img.onload = function() {
        if (this.naturalWidth > this.naturalHeight) {
          this.classList.add('landscape');
          slot.classList.add('has-landscape');
        }
      };
      img.onerror = function() {
        const parent = this.parentElement;
        parent.innerHTML = `<div style='font-size:24px;color:#333'>#${i}</div><div style="position: absolute; top: 5px; right: 5px; background: #ff6b6b; color: white; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: bold;">√ó${count}</div>`;
      };

      slot.innerHTML = `
      <div class="slot-number">#${i}</div>
      <div style="position: absolute; top: 5px; right: 5px; background: #ff6b6b; color: white; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">√ó${count}</div>
    `;
      slot.insertBefore(img, slot.firstChild);
      grid.appendChild(slot);
    });
  }

  // ==================== SIMPLE TRADING SYSTEM ====================

  let currentTradeCode = null;
  let tradeChannel = null;
  let tradeMatch = null;
  let selectedTradeStickers = [];

  // Open trading interface
  function openTrading() {
    document.getElementById('simple-trading').style.display = 'block';
    resetTrading();
    vibrate(10);
  }

  function closeTrading() {
    document.getElementById('simple-trading').style.display = 'none';
    leaveTradeRoom();
    resetTrading();
  }

  function resetTrading() {
    currentTradeCode = null;
    tradeMatch = null;
    selectedTradeStickers = [];

    document.getElementById('trade-code').value = '';
    document.getElementById('trade-status').textContent = 'Waiting for code...';
    document.getElementById('trade-match-section').style.display = 'none';
    document.getElementById('selected-trade-stickers').innerHTML =
            '<p style="margin: 0; color: #999;">Your selected stickers will appear here...</p>';
  }

  // Enter trade code
  async function enterTradeCode() {
    const codeInput = document.getElementById('trade-code');
    const code = codeInput.value.trim();

    if (!code || code.length !== 4 || !/^\d{4}$/.test(code)) {
      //('Please enter a valid 4-digit code (numbers only)');
      return;
    }

    const { data: { user } } = await supabaseClient.auth.getUser();
    if (!user) {
      //('Please login first!');
      return;
    }

    currentTradeCode = code;
    document.getElementById('trade-status').textContent = `Looking for trade match with code: ${code}...`;

    // Create or join trade room
    await joinTradeRoom(code);
  }


  // Join trade room using Supabase realtime
  async function joinTradeRoom(code) {
    const { data: { user } } = await supabaseClient.auth.getUser();
    if (!user) return;

    const username = await getCurrentUsername();
    console.log('Joining trade room as:', username, 'User ID:', user.id);

    // Leave any existing trade room
    if (tradeChannel) {
      console.log('Removing existing channel');
      await supabaseClient.removeChannel(tradeChannel);
    }

    // Subscribe to trade room updates FIRST
    tradeChannel = supabaseClient.channel(`trade-room-${code}-${Date.now()}`, {
      config: {
        broadcast: { self: true }
      }
    })
            .on(
                    'postgres_changes',
                    {
                      event: '*',
                      schema: 'public',
                      table: 'trade_rooms',
                      filter: `code=eq.${code}`
                    },
                    async (payload) => {
                      console.log('Trade room update received:', payload.eventType, payload.new);
                      const room = payload.new;

                      if (room.status === 'matched' && room.player2_id) {
                        console.log('Room matched! Player1:', room.player1_id, 'Player2:', room.player2_id, 'Me:', user.id);
                        // We found a match!
                        if (room.player1_id === user.id) {
                          tradeMatch = {
                            roomId: room.id,
                            otherPlayerId: room.player2_id,
                            otherPlayerName: room.player2_name,
                            code: code
                          };
                        } else {
                          tradeMatch = {
                            roomId: room.id,
                            otherPlayerId: room.player1_id,
                            otherPlayerName: room.player1_name,
                            code: code
                          };
                        }

                        console.log('Trade match set:', tradeMatch);
                        document.getElementById('trade-status').textContent = `‚úÖ Connected with ${tradeMatch.otherPlayerName}!`;
                        showTradeInterface();
                      }

                      if (room.status === 'trading') {
                        console.log('Trade status: trading. Player1 trade:', room.player1_trade, 'Player2 trade:', room.player2_trade);
                        // Check if both players have submitted trades
                        if (room.player1_trade && room.player2_trade && room.player1_trade.length > 0 && room.player2_trade.length > 0) {
                          console.log('Both players submitted trades, completing...');
                          // Both players ready - complete the trade
                          await supabaseClient
                                  .from('trade_rooms')
                                  .update({ status: 'completed' })
                                  .eq('id', room.id);
                        } else {
                          // Load other player's trade selection
                          await loadOtherPlayerTrade(room);
                        }
                      }

                      if (room.status === 'completed') {
                        console.log('Trade completed!');
                        // Trade completed
                        await completeTrade(room);
                      }

                      if (room.status === 'cancelled') {
                        console.log('Trade cancelled');
                        // Trade cancelled
                        document.getElementById('trade-status').textContent = '‚ùå Trade was cancelled by the other player';
                        setTimeout(() => resetTrading(), 2000);
                      }
                    }
            )
            .subscribe(async (status) => {
              console.log('Channel subscription status:', status);

              if (status === 'SUBSCRIBED') {
                // Clean up old rooms first (older than 5 minutes)
                const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000).toISOString();
                await supabaseClient
                        .from('trade_rooms')
                        .delete()
                        .eq('code', code)
                        .lt('created_at', fiveMinutesAgo);

                // Now try to join or create room after subscription is ready
                console.log('Checking for existing room with code:', code);
                const { data: existingRoom, error: checkError } = await supabaseClient
                        .from('trade_rooms')
                        .select('*')
                        .eq('code', code)
                        .eq('status', 'waiting')
                        .maybeSingle();

                console.log('Existing room check result:', existingRoom, 'Error:', checkError);

                if (checkError && checkError.code !== 'PGRST116') {
                  console.error('Error checking trade room:', checkError);
                  return;
                }

                if (existingRoom && existingRoom.player1_id !== user.id) {
                  console.log('Joining existing room created by:', existingRoom.player1_name);
                  // Join existing room
                  const { data: updatedRoom, error: updateError } = await supabaseClient
                          .from('trade_rooms')
                          .update({
                            player2_id: user.id,
                            player2_name: username,
                            status: 'matched',
                            updated_at: new Date().toISOString()
                          })
                          .eq('id', existingRoom.id)
                          .eq('status', 'waiting')
                          .select()
                          .single();

                  if (updateError) {
                    console.error('Error joining room:', updateError);
                    return;
                  }

                  console.log('Successfully joined room, updated data:', updatedRoom);

                  tradeMatch = {
                    roomId: existingRoom.id,
                    otherPlayerId: existingRoom.player1_id,
                    otherPlayerName: existingRoom.player1_name,
                    code: code
                  };

                  document.getElementById('trade-status').textContent = `‚úÖ Connected with ${existingRoom.player1_name}!`;
                  showTradeInterface();

                } else if (!existingRoom) {
                  console.log('Creating new room');
                  // Create new room
                  const { data: newRoom, error: createError } = await supabaseClient
                          .from('trade_rooms')
                          .insert({
                            code: code,
                            player1_id: user.id,
                            player1_name: username,
                            status: 'waiting',
                            player1_trade: [],
                            player2_trade: [],
                            created_at: new Date().toISOString(),
                            updated_at: new Date().toISOString()
                          })
                          .select()
                          .single();

                  if (createError) {
                    console.error('Error creating trade room:', createError);
                    document.getElementById('trade-status').textContent = 'Failed to create trade room';
                    return;
                  }

                  console.log('Room created successfully:', newRoom);
                  document.getElementById('trade-status').textContent = `Waiting for another player to enter code: ${code}...`;
                } else {
                  console.log('Room exists but created by me, waiting for another player');
                  document.getElementById('trade-status').textContent = `Waiting for another player to enter code: ${code}...`;
                }
              }
            });
  }
  
  // Leave trade room
  async function leaveTradeRoom() {
    if (currentTradeCode && tradeChannel) {
      const { data: { user } } = await supabaseClient.auth.getUser();

      // Update room status to cancelled
      await supabaseClient
              .from('trade_rooms')
              .update({ status: 'cancelled' })
              .eq('code', currentTradeCode)
              .eq('status', 'waiting');

      await supabaseClient.removeChannel(tradeChannel);
      tradeChannel = null;
    }
  }

  // Show trade interface after match
  function showTradeInterface() {
    document.getElementById('trade-match-section').style.display = 'block';
    loadMyTradeDuplicates();
  }

  // Load user's duplicate stickers for trading
  function loadMyTradeDuplicates() {
    const grid = document.getElementById('my-trade-duplicates');
    grid.innerHTML = '';

    selectedTradeStickers = [];

    Object.keys(duplicates).forEach(stickerNum => {
      const num = parseInt(stickerNum);
      const count = duplicates[stickerNum];

      // Only show if user has at least 2 of this sticker (so they can trade one and keep one)
      if (count >= 2) {
        const stickerDiv = document.createElement('div');
        stickerDiv.className = 'trade-sticker-item';
        stickerDiv.dataset.number = num;

        const img = document.createElement('img');
        img.src = `images/${num}.png`;
        img.alt = `Sticker #${num}`;
        img.onerror = () => {
          stickerDiv.innerHTML = `<div style="font-size: 20px; color: #333;">#${num}</div>`;
        };

        const numberSpan = document.createElement('div');
        numberSpan.className = 'sticker-number';
        numberSpan.textContent = `#${num} (${count})`;

        stickerDiv.appendChild(img);
        stickerDiv.appendChild(numberSpan);

        stickerDiv.addEventListener('click', () => toggleTradeSticker(num));
        grid.appendChild(stickerDiv);
      }
    });

    if (grid.innerHTML === '') {
      grid.innerHTML = '<p style="grid-column: 1/-1; text-align: center; color: #999; padding: 40px;">No duplicate stickers available for trading (need at least 2 of the same sticker)</p>';
    }
  }

  // Toggle sticker selection for trading
  function toggleTradeSticker(stickerNum) {
    const stickerDiv = document.querySelector(`.trade-sticker-item[data-number="${stickerNum}"]`);
    const index = selectedTradeStickers.indexOf(stickerNum);

    if (index > -1) {
      // Remove from selection
      selectedTradeStickers.splice(index, 1);
      stickerDiv.classList.remove('selected');
    } else {
      // Add to selection
      selectedTradeStickers.push(stickerNum);
      stickerDiv.classList.add('selected');
    }

    updateSelectedTradeDisplay();
  }

  function updateSelectedTradeDisplay() {
    const container = document.getElementById('selected-trade-stickers');

    if (selectedTradeStickers.length === 0) {
      container.innerHTML = '<p style="margin: 0; color: #999;">Your selected stickers will appear here...</p>';
      return;
    }

    let html = '<p style="margin: 0 0 10px 0; font-weight: bold;">Trading these stickers:</p>';
    html += '<div style="display: flex; flex-wrap: wrap; gap: 8px;">';

    selectedTradeStickers.forEach(stickerNum => {
      html += `<span style="background: #4CAF50; color: white; padding: 5px 10px; border-radius: 12px; font-size: 14px;">#${stickerNum}</span>`;
    });

    html += '</div>';
    container.innerHTML = html;
  }

  // Load other player's trade selection
  async function loadOtherPlayerTrade(room) {
    if (!tradeMatch) return;

    const otherPlayerTrade = room.player1_trade || room.player2_trade;
    const isMyTrade = room.player1_id === (await supabaseClient.auth.getUser()).data.user.id ?
            room.player1_trade : room.player2_trade;

    if (otherPlayerTrade && !isMyTrade) {
      // Show other player's selection
      document.getElementById('trade-status').textContent =
              `‚úÖ ${tradeMatch.otherPlayerName} is ready to trade ${otherPlayerTrade.length} sticker(s)!`;
    }
  }

  // Confirm trade
  async function confirmTrade() {
    if (selectedTradeStickers.length === 0) {
      //('Please select at least one sticker to trade!');
      return;
    }

    if (!tradeMatch) {
      //('No trade match found!');
      return;
    }

    const { data: { user } } = await supabaseClient.auth.getUser();
    const isPlayer1 = user.id === tradeMatch.otherPlayerId ? false : true;

    // Update room with trade selection
    const updateData = isPlayer1 ?
            { player1_trade: selectedTradeStickers, status: 'trading' } :
            { player2_trade: selectedTradeStickers, status: 'trading' };

    const { error } = await supabaseClient
            .from('trade_rooms')
            .update(updateData)
            .eq('code', currentTradeCode);

    if (error) {
      console.error('Error updating trade:', error);
      //('Failed to send trade request');
      return;
    }

    document.getElementById('trade-status').textContent =
            `‚úÖ Trade request sent! Waiting for ${tradeMatch.otherPlayerName} to confirm...`;
  }

  // Complete trade
  async function completeTrade(room) {
    const { data: { user } } = await supabaseClient.auth.getUser();
    const myTrade = room.player1_id === user.id ? room.player1_trade : room.player2_trade;
    const otherTrade = room.player1_id === user.id ? room.player2_trade : room.player1_trade;

    if (!myTrade || !otherTrade) {
      //('Trade data incomplete!');
      return;
    }

    // Remove traded stickers from my duplicates
    myTrade.forEach(stickerNum => {
      if (duplicates[stickerNum]) {
        duplicates[stickerNum]--;
        if (duplicates[stickerNum] <= 0) {
          delete duplicates[stickerNum];
        }
      }
    });

    // Add received stickers to my collection or duplicates
    otherTrade.forEach(stickerNum => {
      if (userCollection.includes(stickerNum)) {
        duplicates[stickerNum] = (duplicates[stickerNum] || 0) + 1;
      } else {
        userCollection.push(stickerNum);
      }
    });

    // Save game
    await saveGame();

    // Show success message
    document.getElementById('trade-status').textContent =
            `üéâ Trade completed! You received ${otherTrade.length} sticker(s) and gave ${myTrade.length} sticker(s)`;

    // Reset after delay
    setTimeout(() => {
      closeTrading();
      //('Trade completed successfully!');
    }, 3000);
  }

  // Cancel trade
  async function cancelTrade() {
    if (currentTradeCode) {
      await supabaseClient
              .from('trade_rooms')
              .update({ status: 'cancelled' })
              .eq('code', currentTradeCode);
    }

    closeTrading();
  }

  // Initialize
  async function initialize() {
    // Always show auth box on initial load
    authBox.style.display = "flex";
    document.body.classList.add("locked");

    // Check if user is already logged in
    const { data: { user } } = await supabaseClient.auth.getUser();
    if (user) {
      hideAuthBox();
      await loadGame();
    }

    // Set up event listeners
    document.getElementById('open-pack').addEventListener('click', openPack);
    document.getElementById('save-btn').addEventListener('click', async () => {
      const saved = await saveGame();
      if (saved) {
        //('Game saved successfully!');
      } else {
        //('Failed to save game!');
      }
    });

    document.getElementById('reset-btn').addEventListener('click', resetGame);
    document.getElementById('coin-flip').addEventListener('click', coinFlipGame);

    document.getElementById('album-btn').addEventListener('click', () => {
      document.getElementById('album').style.display = 'block';
      refreshAlbum();
      vibrate(10);
    });

    document.getElementById('duplicates-btn').addEventListener('click', () => {
      document.getElementById('duplicates').style.display = 'block';
      refreshDuplicates();
      vibrate(10);
    });

    document.getElementById('sell-duplicates').addEventListener('click', async () => {
      const duplicateKeys = Object.keys(duplicates);
      if (duplicateKeys.length === 0) {
        //('No duplicates to sell!');
        return;
      }

      let totalDuplicates = 0;
      duplicateKeys.forEach(key => {
        totalDuplicates += duplicates[key];
      });

      coins += totalDuplicates;

      for (let key in duplicates) {
        delete duplicates[key];
      }

      updateLabels();
      refreshDuplicates();
      const saved = await saveGame();
      if (saved) {
        vibrate(50);
        //(`Sold ${totalDuplicates} duplicates for ${totalDuplicates} coins!`);
      } else {
        //("Failed to save after selling duplicates!");
      }
    });

    // Auth event listeners
    document.getElementById("login-btn").addEventListener("click", loginWithUsername);
    document.getElementById("signup-btn").addEventListener("click", signUpWithUsername);
    document.getElementById("logout-btn").addEventListener("click", logout);

    // Allow Enter key for login
    document.getElementById("username").addEventListener("keypress", (e) => {
      if (e.key === "Enter") loginWithUsername();
    });

    document.getElementById("password").addEventListener("keypress", (e) => {
      if (e.key === "Enter") loginWithUsername();
    });

    // Trading event listeners
    document.getElementById('trading-btn').addEventListener('click', openTrading);
    document.getElementById('enter-trade-code').addEventListener('click', enterTradeCode);
    document.getElementById('confirm-trade-btn').addEventListener('click', confirmTrade);
    document.getElementById('cancel-trade-btn').addEventListener('click', cancelTrade);

    // Allow Enter key in trade code input
    document.getElementById('trade-code').addEventListener('keypress', (e) => {
      if (e.key === "Enter") enterTradeCode();
    });
  }

  // Initialize the app
  initialize();
  updateLabels();
</script>

<footer style="margin: 30px 0; font-size: 14px; text-align: center;">
  <a href="about.html">About</a> |
  <a href="privacy.html">Privacy Policy</a> |
  <a href="contact.html">Contact</a>
</footer>

</body>
</html>